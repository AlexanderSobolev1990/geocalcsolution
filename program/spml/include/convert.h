//----------------------------------------------------------------------------------------------------------------------
///
/// \file       convert.h
/// \brief      Переводы единиц библиотеки СБПМ
/// \date       27.07.20 - создан
/// \author     Соболев А.А.
/// \addtogroup spml
/// \{
///

#ifndef SPML_CONVERT_H
#define SPML_CONVERT_H

// System includes:
#include <cmath>
#include <ctime>
#include <string>
#include <cassert>
#include <type_traits>

// SPML includes:
#include <consts.h>
#include <units.h>

namespace SPML /// Специальная библиотека программных модулей (СБ ПМ)
{
namespace Convert /// Переводы единиц
{
//----------------------------------------------------------------------------------------------------------------------
// Константы перевода радианов в градусы и наоборот
const float DgToRdF = static_cast<float>( std::asin( 1.0 ) / 90.0 ); ///< Перевод градусов в радианы (float) путем умножения на данную константу
const float RdToDgF = static_cast<float>( 90.0 / std::asin( 1.0 ) ); ///< Перевод радианов в градусы (float) путем умножения на данную константу
const double DgToRdD = std::asin( 1.0 ) / 90.0;                      ///< Перевод градусов в радианы (double) путем умножения на данную константу
const double RdToDgD = 90.0 / std::asin( 1.0 );                      ///< Перевод радианов в градусы (double) путем умножения на данную константу

//----------------------------------------------------------------------------------------------------------------------
// Перевод дальности в задержку и наоборот исходя из формулы R = C*tau/2 путем умножения на данную константу
//const double MsToMetersD_half = Consts::C_D * 0.5 * 1.0e-3; ///< Перевод задержки [мс] в дальность [м] путем умножения на данную константу (по формуле R = C * Tau / 2 )
//const double MetersToMsD_half = 1.0 / MsToMetersD_half; ///< Перевод дальности [м] в задержку [мс] путем умножения на данную константу (по формуле Tau = 2 * R / C )

const double MsToKmD_half = Consts::C_D * 0.5 * 1.0e-6; ///< Перевод задержки [мс] в дальность [км] путем умножения на данную константу (по формуле R = C * Tau / 2 )
const double KmToMsD_half = 1.0 / MsToKmD_half; ///< Перевод дальности [км] в задержку [мс] путем умножения на данную константу (по формуле Tau = 2 * R / C )

//const double McsToMetersD_half = Consts::C_D * 0.5 * 1.0e-6; ///< Перевод задержки [мкс] в дальность [м] путем умножения на данную константу (по формуле R = C * Tau / 2 )
//const double MetersToMcsD_half = 1.0 / McsToMetersD_half; ///< Перевод дальности [м] в задержку [мкс] путем умножения на данную константу (по формуле Tau = 2 * R / C )

const double McsToKmD_half = Consts::C_D * 0.5 * 1.0e-9; ///< Перевод задержки [мкс] в дальность [км] путем умножения на данную константу (по формуле R = C * Tau / 2 )
const double KmToMcsD_half = 1.0 / McsToKmD_half; ///< Перевод дальности [км] в задержку [мкс] путем умножения на данную константу (по формуле Tau = 2 * R / C )

//const double SecToMetersD_half = Consts::C_D * 0.5; ///< Перевод задержки [с] в дальность [м] путем умножения на данную константу (по формуле R = C * Tau / 2 )
//const double MetersToSecD_half = 1.0 / SecToMetersD_half; ///< Перевод дальности [м] в задержку [с] путем умножения на данную константу (по формуле Tau = 2 * R / C )

//const double SecToKmD_half = Consts::C_D * 0.5 * 1.0e-3; ///< Перевод задержки [с] в дальность [км] путем умножения на данную константу (по формуле R = C * Tau / 2 )
//const double KmToSecD_half = 1.0 / SecToKmD_half; ///< Перевод дальности к[м] в задержку [с] путем умножения на данную константу (по формуле Tau = 2 * R / C )

////----------------------------------------------------------------------------------------------------------------------
//// Перевод дальности в задержку и наоборот исходя из формулы R = C*tau путем умножения на данную константу
const double MsToMetersD_full = Consts::C_D * 1.0e-3; ///< Перевод задержки [мс] в дальность [м] путем умножения на данную константу (по формуле R = C * Tau / 2 )
const double MetersToMsD_full = 1.0 / MsToMetersD_full; ///< Перевод дальности [м] в задержку [мс] путем умножения на данную константу (по формуле Tau = 2 * R / C )

const double MsToKmD_full = Consts::C_D * 1.0e-6; ///< Перевод задержки [мс] в дальность [км] путем умножения на данную константу (по формуле R = C * Tau / 2 )
const double KmToMsD_full = 1.0 / MsToKmD_full; ///< Перевод дальности [км] в задержку [мс] путем умножения на данную константу (по формуле Tau = 2 * R / C )

//const double McsToMetersD_full = Consts::C_D * 1.0e-6; ///< Перевод задержки [мкс] в дальность [м] путем умножения на данную константу (по формуле R = C * Tau / 2 )
//const double MetersToMcsD_full = 1.0 / McsToMetersD_full; ///< Перевод дальности [м] в задержку [мкс] путем умножения на данную константу (по формуле Tau = 2 * R / C )

//const double McsToKmD_full = Consts::C_D * 1.0e-9; ///< Перевод задержки [мкс] в дальность [км] путем умножения на данную константу (по формуле R = C * Tau / 2 )
//const double KmToMcsD_full = 1.0 / McsToKmD_full; ///< Перевод дальности [км] в задержку [мкс] путем умножения на данную константу (по формуле Tau = 2 * R / C )

//const double SecToMetersD_full = Consts::C_D; ///< Перевод задержки [с] в дальность [м] путем умножения на данную константу (по формуле R = C * Tau / 2 )
//const double MetersToSecD_full = 1.0 / SecToMetersD_full; ///< Перевод дальности [м] в задержку [с] путем умножения на данную константу (по формуле Tau = 2 * R / C )

//const double SecToKmD_full = Consts::C_D * 1.0e-3; ///< Перевод задержки [с] в дальность [км] путем умножения на данную константу (по формуле R = C * Tau / 2 )
//const double KmToSecD_full = 1.0 / SecToKmD_full; ///< Перевод дальности к[м] в задержку [с] путем умножения на данную константу (по формуле Tau = 2 * R / C )

//----------------------------------------------------------------------------------------------------------------------
///
/// \brief Приведение угла в [0,360) градусов или [0,2PI) радиан
/// \param[in] angle - приводимый угол в [град] или [рад] в зависимости от параметра.
/// \param[in] au    - выбор угловых единиц [град] или [рад]
/// \return Значение angle, приведенное в [0,360) градусов или [0,2PI) радиан
///
float AngleTo360( float angle, const Units::TAngleUnit &au );

///
/// \brief Приведение угла в [0,360) градусов или [0,2PI) радиан
/// \param[in] angle - приводимый угол в [град] или [рад] в зависимости от параметра.
/// \param[in] au    - выбор угловых единиц [град] или [рад]
/// \return Значение angle, приведенное в [0,360) градусов или [0,2PI) радиан
///
double AngleTo360( double angle, const Units::TAngleUnit &au );

//----------------------------------------------------------------------------------------------------------------------
///
/// \brief Приведение угла места в [-90,90] градусов или [-PI/2, PI/2] радиан
/// \param[in] angle - приводимый угол в [град] или [рад] в зависимости от параметра.
/// \param[in] au    - выбор угловых единиц [град] или [рад]
/// \return Значение angle, приведенное в [-90,90] градусов или [-PI/2, PI/2] радиан
///
float EpsToMP90( float angle, const Units::TAngleUnit &au );

///
/// \brief Приведение угла места в [-90,90] градусов или [-PI/2, PI/2] радиан
/// \param[in] angle - приводимый угол в [град] или [рад] в зависимости от параметра.
/// \param[in] au    - выбор угловых единиц [град] или [рад]
/// \return Значение angle, приведенное в [-90,90] градусов или [-PI/2, PI/2] радиан
///
double EpsToMP90( double angle, const Units::TAngleUnit &au );

//----------------------------------------------------------------------------------------------------------------------
///
/// \brief Перевод абсолютного азимута относительно севера в азимут относительно указанного направления
/// \param[in] absAz  - абсолютный азимут относительно севера
/// \param[in] origin - абсолютный азимут, относительно которого измеряется относительный
/// \param[in] au     - единицы измерения углов входных/выходных параметров
/// \return Азимут относительно указанного направления origin (положительный азимут 0..180 по часовой стрелке, отрицательный 0..-180 против часовой стрелки)
///
template <class T>
inline T AbsAzToRelAz( T absAz, T origin, const Units::TAngleUnit &au )
{
    static_assert( std::is_same<T, float>::value || std::is_same<T, double>::value, "wrong template class!" );
    T result = AngleTo360( absAz, au ) - origin ;
    return result;
}

///
/// \brief Перевод относительного азимута в абсолютный азимут относительно севера
/// \details Единицы измерения углов входных/выходных параметров согласно TAngleUnit
/// \param[in] relAz  - относительный азимут
/// \param[in] origin - абсолютный азимут, относительно которого измеряется relAz
/// \param[in] au     - единицы измерения углов входных/выходных параметров
/// \return Абсолютный азимут относительно севера
///
template <class T>
inline T RelAzToAbsAz( T relAz, T origin, const Units::TAngleUnit &au )
{
    static_assert( ( std::is_same<T, float>::value ) || ( std::is_same<T, double>::value ), "wrong template class!" );
    T result = AngleTo360( ( relAz + origin ), au );
    return result;
}

//----------------------------------------------------------------------------------------------------------------------
///
/// \brief Перевод [дБ] в разы по мощности
/// \param[in] dB - децибелы
/// \return децибелы, перевденные в разы по мощности
///
template <class T>
inline T dBtoTimesByP( T dB )
{
    static_assert( ( std::is_same<T, float>::value ) || ( std::is_same<T, double>::value ), "wrong template class!" );
    return ( std::pow( 10.0, ( dB * 0.1 ) ) ); // 10 ^ ( dB / 10 )
}

///
/// \brief Перевод [дБ] в разы по напряжению
/// \param[in] dB - децибелы
/// \return децибелы, перевденные в разы по напряжению
///
template <class T>
inline T dBtoTimesByU( T dB )
{
    static_assert( ( std::is_same<T, float>::value ) || ( std::is_same<T, double>::value ), "wrong template class!" );
    return ( std::pow( 10.0, ( dB * 0.05 ) ) ); // 10 ^ ( dB / 20 )
}

static int dummy_int;
//----------------------------------------------------------------------------------------------------------------------
///
/// \brief Перевод целого числа секунд с 00:00:00 01.01.1970 в часы/минуты/секунды/день/месяц/год
/// \param[in] rawtime - число секунд с 00:00:00 01.01.1970
/// \param[out] hour - часы
/// \param[out] min - минуты
/// \param[out] sec - секунды
/// \param[out] day - день
/// \param[out] mon - месяц
/// \param[out] year - год
///
void UnixTimeToHourMinSec( int rawtime, int &hour, int &min, int &sec, int &day = dummy_int, int &mon = dummy_int, int &year = dummy_int );

//----------------------------------------------------------------------------------------------------------------------
///
/// \brief Получение текущей даты и времени
/// \return Возвращает текущую дату в строке формата YYYY-MM-DD.HH:mm:ss
///
const std::string CurrentDateTimeToString();

//----------------------------------------------------------------------------------------------------------------------
///
/// \brief Проверка разницы в углах
/// \details Например, A1=10, A2=30, тогда разница=20, но если A1=10, а A2=350, то разница тоже 20, а не A2-A1=340 !
/// \param deltaAngle - Разница в углах
/// \param au - Единицы измерения разницы углов
/// \return Разница в углах, приведенная в 0-180 градусов (0-PI/2 радиан)
///
double CheckDeltaAngle( double deltaAngle, const SPML::Units::TAngleUnit &au );

} // end namespace Convert
} // end namespace SPML
#endif // SPML_CONVERT_H
/// \}
